# -*- coding: utf-8 -*-
"""E-commerce code_!.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/116l-vjeNpHLcyVLf0BgF-JgZtCiPW-OS
"""

import pandas as pd

df = pd.read_csv("/content/drive/MyDrive/Amazon Sale Report.csv")

df.shape

df.head()

df.columns

"""1. 'index': This column appears to be an index or identifier for each row in the

dataset.

2. 'Order ID': A unique identifier for each order made by a customer.

3. 'Date': The date when the order was placed.

4. 'Status': The status of the order, which could indicate whether it's processing, shipped, delivered, etc.

5. 'Fulfillment': Information related to how the order is being fulfilled, such as whether it's fulfilled by a third party or the e-commerce company itself.

6. 'Sales Channel': The channel or platform through which the sale was made, like the website, app, or a specific marketplace.

7. 'ship-service-level': The level of shipping service chosen for the order, which might include options like standard shipping, expedited shipping, or next-day delivery.

8. 'Style': The style of the product being ordered, which might refer to its design or model.

9. 'SKU': Stock Keeping Unit, a unique code or identifier for a specific product.

10. 'Category': The category or product type to which the ordered item belongs, such as electronics, clothing, or accessories.

11. 'Size': The size of the ordered product, applicable for items like clothing or shoes.

12. 'ASIN': Amazon Standard Identification Number, a unique identifier used primarily for products on Amazon's platform.

13. 'Courier Status': The status of the courier or shipping company handling the delivery.

14. 'Qty': The quantity of the ordered item.

15. 'currency': The currency in which the transaction amount is recorded.

16. 'Amount': The total amount of the order, typically in the currency mentioned above.

17. 'ship-city': The city to which the order is being shipped.

18. 'ship-state': The state or region within the country where the order is being shipped.

19. 'ship-postal-code': The postal or ZIP code of the shipping destination.

20. 'ship-country': The country to which the order is being shipped.

21. 'promotion-ids': Any promotion or discount codes applied to the order.

22. 'B2B': Indicates whether the order is a business-to-business (B2B) transaction.

23. 'fulfilled-by': Information about who is responsible for order fulfillment, whether it's the e-commerce company itself or a third-party seller.
"""

df.drop("Unnamed: 22", axis=1, inplace=True)

df.info()

df.isna().sum()

df.describe()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Set style for Seaborn plots (optional)
sns.set(style="whitegrid")

# Visualize missing data
plt.figure(figsize=(10, 6))
sns.heatmap(df.isnull(), cbar=False, cmap='viridis')
plt.title('Missing Data Visualization')
plt.show()

# Handling Missing Values (Replace with appropriate strategy)
df['Courier Status'].fillna('Unknown', inplace=True)
df.dropna(subset=['currency', 'Amount', 'ship-city', 'ship-state', 'ship-postal-code', 'ship-country',], inplace=True)

# Visualize missing data
plt.figure(figsize=(10, 6))
sns.heatmap(df.isnull(), cbar=False, cmap='viridis')
plt.title('Missing Data Visualization')
plt.show()

"""The Promotion ids and Fullfilled by columns has soo ,many missing values so I will drop them"""

df.drop("promotion-ids", axis=1, inplace=True)

df.drop("fulfilled-by", axis=1, inplace=True)

# Visualize missing data
plt.figure(figsize=(10, 6))
sns.heatmap(df.isnull(), cbar=False, cmap='viridis')
plt.title('Missing Data Visualization')
plt.show()

"""**Great The Missing values have been eliminated**"""

# Countplot for 'Status' column
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='Status')
plt.title('Order Status Count')
plt.xticks(rotation=45)
plt.show()

# Barplot for 'Sales Channel'
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='Sales Channel ')
plt.title('Sales Channel Distribution')
plt.xticks(rotation=45)
plt.show()

# Histogram for 'Amount'
plt.figure(figsize=(10, 6))
sns.histplot(data=df, x='Amount', bins=30, kde=True)
plt.title('Distribution of Order Amount')
plt.xlabel('Amount')
plt.ylabel('Frequency')
plt.show()

# Boxplot for 'Amount' by 'Status'
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='Status', y='Amount')
plt.title('Order Amount by Status')
plt.xticks(rotation=45)
plt.show()

# Pairplot for numeric columns (Qty and Amount)
sns.pairplot(data=df[['Qty', 'Amount']])
plt.suptitle('Pairplot for Numeric Columns')
plt.show()

# Countplot for 'B2B'
plt.figure(figsize=(8, 5))
sns.countplot(data=df, x='B2B')
plt.title('B2B vs. B2C Orders')
plt.xticks([0, 1], ['B2C', 'B2B'])
plt.show()

# Countplot for 'Fulfilment'
plt.figure(figsize=(8, 5))
sns.countplot(data=df, x='Fulfilment')
plt.title('Fulfilment Type Distribution')
plt.xticks(rotation=45)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Create a box plot to visualize the relationship between 'Amount' and 'Status'
plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='Status', y='Amount')
plt.title('Relationship between Amount and Status')
plt.xticks(rotation=45)
plt.xlabel('Status')
plt.ylabel('Amount')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Create a violin plot to visualize the relationship between 'Amount' and 'Status'
plt.figure(figsize=(12, 6))
sns.violinplot(data=df, x='Status', y='Amount')
plt.title('Distribution of Amount by Status')
plt.xticks(rotation=45)
plt.xlabel('Status')
plt.ylabel('Amount')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Create a countplot to visualize the relationship between 'ship-country' and 'Status'
plt.figure(figsize=(14, 6))
sns.countplot(data=df, x='ship-country', hue='Status', palette='viridis')
plt.title('Relationship between Ship Country and Status')
plt.xticks(rotation=45)
plt.xlabel('Ship Country')
plt.ylabel('Count')
plt.legend(title='Status', title_fontsize='12')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Create a box plot to visualize the relationship between 'Qty' and 'Status'
plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='Status', y='Qty')
plt.title('Relationship between Quantity and Status')
plt.xticks(rotation=45)
plt.xlabel('Status')
plt.ylabel('Quantity')
plt.show()

"""**Loading the data set**"""

de = pd.read_excel("/content/drive/MyDrive/output.xlsx")

"""**Checking the first few rows**"""

de.head()

"""**Data Exploration**

**Investigating more information about the data set using the info function**
"""

de.info()

de.describe()

de.columns

de.isna().sum()

"""**Data Visualization**"""

de.hist()

# 1. Group the data by 'category' and 'sub_category'
category_counts = de.groupby(['category', 'sub_category']).size().reset_index(name='count')


# 2. Sort the categories/sub-categories by the count of products in descending order
category_counts = category_counts.sort_values(by='count', ascending=False)

# 3. Print the most popular categories and sub-categories
print("Most Popular Categories and Sub-Categories:")
print(category_counts.head(10))

# 4. Plot a bar chart to visualize the distribution of products across categories
import matplotlib.pyplot as plt

top_categories = category_counts.head(10)
plt.figure(figsize=(12, 6))
plt.bar(top_categories['category'], top_categories['count'])
plt.xlabel('Category')
plt.ylabel('Count')
plt.title('Top 10 Categories')
plt.xticks(rotation=90)
plt.show()

"""From the above visualization its clear that Clothing and Accessories category is purchased so much

"""

import numpy as np
import matplotlib.pyplot as plt

# 1. Group the data by 'brand' and count the occurrences
brand_counts = de['brand'].value_counts().reset_index()
brand_counts.columns = ['Brand', 'Count']

# 2. Sort the brands by the count of products in descending order
brand_counts = brand_counts.sort_values(by='Count', ascending=False)

# 3. Print the most popular brands with colored text
print("\033[1m\033[94mMost Popular Brands:\033[0m")
print(brand_counts.head(10))

# 4. Plot a bar chart to visualize the distribution of products across brands with different colors
top_brands = brand_counts.head(10)
colors = plt.cm.Paired(np.arange(len(top_brands)))
plt.figure(figsize=(12, 6))
bars = plt.bar(top_brands['Brand'], top_brands['Count'], color=colors)
plt.xlabel('Brand')
plt.ylabel('Count')
plt.title('Top 10 Brands')
plt.xticks(rotation=45)
plt.tight_layout()

# Add labels to the bars with colored text
for bar, count in zip(bars, top_brands['Count']):
    plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height(), count, ha='center', va='bottom', color='red')

plt.show()

import seaborn as sns
# we take a allsample brand and try seeing if based on the brand does the price rise
plt.figure(figsize=(15, 10))

# Subsample the data for better visualization
subset_de = de.sample(n=60)  # Adjust the number of samples as needed

# Line plot for 'brand'

sns.lineplot(data=subset_de, x='actual_price', y='brand')
plt.xticks(rotation='vertical')
plt.title("Market presence of different brands")
plt.show()

brands_to_plot = ['ARBO', 'Pu', 'True Bl', 'REEB', 'ECKO Unl', 'Free Authori', 'Keo', 'Amp', 'Black Beat', 'PixF', 'yellowvib', 'vims rai']

plt.figure(figsize=(15, 10))

# Filter the DataFrame for the specified brands
filtered_de = de[de['brand'].isin(brands_to_plot)]
# Line plot for 'average_rating'
sns.lineplot(data=filtered_de, x=filtered_de.index, y='average_rating', hue='brand')
plt.title('average_rating based on the most popular brand')

plt.show()

import seaborn as sns

# Consider top 50 sellers
seller_counts = de['seller'].value_counts().head(50)
# Consider top 50 selling prices
selling_price_counts = de['selling_price'].value_counts().head(50)

plt.figure(figsize=(20, 15))

# Specify different colors for Seller Counts and Selling Price Counts
sns.barplot(x=seller_counts.index, y=seller_counts.values, color='purple', label='Seller Counts')
sns.barplot(x=selling_price_counts.index, y=selling_price_counts.values, color='green', label='Selling Price Counts')

plt.xticks(rotation='vertical')
plt.xlabel('Seller / Selling Price')
plt.ylabel('Count')
plt.title('Top 50 Sellers and Selling Prices')
plt.legend()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Consider top 50 sellers
seller_counts = de['seller'].value_counts().head(50)

# Consider top 50 selling prices
category_counts = de['category'].value_counts().head(50)

plt.figure(figsize=(12, 10))

# Create a bar plot for the top sellers in blue
sns.barplot(x=seller_counts.index, y=seller_counts.values, color='blue', label='Seller Counts')

# Create a second bar plot for the top categories in orange
sns.barplot(x=category_counts.index, y=category_counts.values, color='orange', label='Category Counts')

plt.xticks(rotation='vertical')
plt.xlabel('Seller / Category')
plt.ylabel('Count')
plt.title('Top 50 Sellers and Category Prices')
plt.legend()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline
import warnings
warnings.filterwarnings('ignore')

# Data exploration
print("Number of records:", len(de))
print("Columns:", de.columns)

#summary statistics
print('\nSummary Statistics')
print(de.describe(datetime_is_numeric=True))

def data_preprocessing_pipeline(data):
    #Identify numeric and categorical features
    numeric_features = de.select_dtypes(include=['float', 'int']).columns
    categorical_features = de.select_dtypes(include=['object']).columns

    #Handle missing values in numeric features
    de[numeric_features] = de[numeric_features].fillna(de[numeric_features].mean())

    #Detect and handle outliers in numeric features using IQR
    for feature in numeric_features:
        Q1 = de[feature].quantile(0.25)
        Q3 = de[feature].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - (1.5 * IQR)
        upper_bound = Q3 + (1.5 * IQR)
        de[feature] = np.where((de[feature] < lower_bound) | (de[feature] > upper_bound),
                                 de[feature].mean(), de[feature])
        #Normalize numeric features
    scaler = StandardScaler()
    scaled_data = scaler.fit_transform(de[numeric_features])
    de[numeric_features] = scaler.transform(de[numeric_features])

    #Handle missing values in categorical features
    de[categorical_features] = de[categorical_features].fillna(de[categorical_features].mode().iloc[0])

    # Remove non-numeric characters from 'discount' column
    de['discount'] = de['discount'].str.replace('% off', '')

    return de

# Convert 'average_rating' to numeric
de['average_rating'] = pd.to_numeric(de['average_rating'], errors='coerce')

# Bar plot of average rating by brand with a different style
plt.figure(figsize=(20, 12))
sns.set(style="whitegrid")  # Change the plot style
sns.barplot(
    x='brand',
    y='average_rating',
    data=de,
    estimator=pd.Series.mean,
    ci=None,
    order=de.groupby('brand')['average_rating'].mean().sort_values(ascending=False).index
)
plt.title('Average Rating by Brand')
plt.xlabel('Brand')
plt.ylabel('Average Rating')
plt.xticks(rotation=45)  # Adjusted rotation for better readability
plt.show()

"""**Changing non Numerical Data to numerical as part of cleaning to prepare the data for machine learning**"""

de['actual_price'] = pd.to_numeric(de['actual_price'].str.replace(',', ''), errors='coerce')
mean_price = de['actual_price'].mean()
de['actual_price'].fillna(mean_price, inplace=True)

de['actual_price'] = de['actual_price'].astype(int)

de['selling_price'] = pd.to_numeric(de['selling_price'].str.replace(',', ''), errors='coerce')
mean_price = de['selling_price'].mean()
de['selling_price'].fillna(mean_price, inplace=True)
de['selling_price'] = de['selling_price'].astype(int)

# Scatter plot of actual price vs. selling price with a different style
plt.figure(figsize=(10, 6))
plt.scatter(de['actual_price'], de['selling_price'], s=30, alpha=0.5, color='green', marker='o')
plt.xlabel('Actual Price (in Currency)')
plt.ylabel('Selling Price (in Currency)')
plt.title('Price Comparison: Actual Price vs. Selling Price')
plt.grid(True)
plt.show()

# Box plot of selling price by category
plt.figure(figsize=(12,6))
sns.boxplot(x='category', y='selling_price',data=de)
plt.title('Selling Price by Category')
plt.xlabel('Category')
plt.ylabel('Selling Price')
plt.xticks(rotation=90)
plt.show()

# Bar plot of brand counts with adjusted output
plt.figure(figsize=(50, 10))  # Adjusted figure size
sns.countplot(x='brand', data=de)
plt.title('Brand Counts')
plt.xlabel('Brand')
plt.ylabel('Counts')  # Adjusted label position
plt.xticks(rotation=45)  # Adjusted rotation for better readability
plt.show()

#count of products in each subcategory

plt.figure(figsize=(30,6))
sns.countplot(x='sub_category',data=de)
plt.title('Count of Products in each Subcategory')
plt.xlabel('Sub Category')
plt.ylabel('Counts')
plt.xticks(rotation=90)
plt.show()

# Distribution of Average Rating by Category with a different style
plt.figure(figsize=(10, 6))  # Adjusted figure size
sns.boxplot(x='category', y='average_rating', data=de, palette="Set2")  # Used a boxplot with a different color palette
plt.xticks(rotation=45)  # Adjusted rotation for better readability
plt.xlabel('Category')
plt.ylabel('Average Rating')
plt.title('Average Rating Distribution by Category')
plt.show()

# Create a correlation matrix
correlation_matrix = de.corr()

# Plot the correlation matrix with different styling
plt.figure(figsize=(10, 8))
cmap = sns.diverging_palette(220, 20, as_cmap=True)  # Use a diverging color palette
sns.heatmap(correlation_matrix, annot=True, cmap=cmap, linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()

"""**Further data Cleaning Feature Engineering and Machine Learning**"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.tree import DecisionTreeRegressor
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.ensemble import RandomForestRegressor

from google.colab import drive
drive.mount('/content/drive')

# Save the DataFrame to an Excel file
de.to_excel('output (1).xlsx', index=False)

from google.colab import files

# Download the file
files.download('output (1).xlsx')

"""After cleaning the data in the above codes I load it here. Now the clean version of it so as to do the machine learning part"""

# Load the cleaned dataset
df_cleaned = pd.read_excel('/content/drive/MyDrive/output (1).xlsx')

# Display the first few rows of the cleaned dataset
df_cleaned.head()

# Checking the info of the dataset
df_cleaned.info()

# Checking for missing values
missing_values_cleaned = df_cleaned.isnull().sum()

missing_values_cleaned

# Remove rows with missing values
df_cleaned = df_cleaned.dropna()

# Recheck for missing values
missing_values_cleaned = df_cleaned.isnull().sum()

missing_values_cleaned

# Find non-numeric entries in 'discount' column of the cleaned dataset
non_numeric_discount_cleaned = df_cleaned[~df_cleaned['discount'].str.replace('% off', '').str.isnumeric()]

non_numeric_discount_cleaned

# Replace non-numeric entries in 'discount' column with 0
df_cleaned.loc[~df_cleaned['discount'].str.replace('% off', '').str.isnumeric(), 'discount'] = '0% off'

# Convert 'discount' to numeric values
df_cleaned['discount'] = df_cleaned['discount'].str.replace('% off', '').astype(float)

# Check the changes
df_cleaned[['actual_price', 'selling_price', 'discount', 'average_rating']].info()

# Top 10 brands with the most products in the cleaned dataset
top_brands_cleaned = df_cleaned['brand'].value_counts()[:10]

# Distribution of product categories in the cleaned dataset
category_dist_cleaned = df_cleaned['category'].value_counts()

# Distribution of product sub-categories in the cleaned dataset
sub_category_dist_cleaned = df_cleaned['sub_category'].value_counts()

# Plotting
fig, axes = plt.subplots(3, 1, figsize=(12, 18))

# Top 10 brands with the most products
sns.barplot(x=top_brands_cleaned.values, y=top_brands_cleaned.index, ax=axes[0], palette="viridis")
axes[0].set_title('Top 10 Brands with Most Products in Cleaned Dataset')
axes[0].set_xlabel('Number of Products')
axes[0].set_ylabel('Brand')

# Distribution of product categories
sns.barplot(x=category_dist_cleaned.values, y=category_dist_cleaned.index, ax=axes[1], palette="magma")
axes[1].set_title('Distribution of Product Categories in Cleaned Dataset')
axes[1].set_xlabel('Number of Products')
axes[1].set_ylabel('Category')

# Distribution of product sub-categories
sns.barplot(x=sub_category_dist_cleaned.values, y=sub_category_dist_cleaned.index, ax=axes[2], palette="plasma")
axes[2].set_title('Distribution of Product Sub-Categories in Cleaned Dataset')
axes[2].set_xlabel('Number of Products')
axes[2].set_ylabel('Sub-Category')

plt.tight_layout()
plt.show()

# Check the data types of 'actual_price' and 'selling_price' columns
print(df_cleaned['actual_price'].dtype)
print(df_cleaned['selling_price'].dtype)

# Remove commas from 'actual_price' and 'selling_price' columns and convert to float
df_cleaned['actual_price'] = df_cleaned['actual_price'].str.replace(',', '').astype(float)
df_cleaned['selling_price'] = df_cleaned['selling_price'].str.replace(',', '').astype(float)


# Plotting histograms and boxplots for numerical columns
fig, ax = plt.subplots(2, 2, figsize=(15, 10))
# 'actual_price'
sns.histplot(df_cleaned['actual_price'], bins=30, ax=ax[0, 0])
sns.boxplot(df_cleaned['actual_price'], ax=ax[0, 1])
ax[0, 0].set_title('Distribution of Actual Price in Cleaned Dataset')
ax[0, 1].set_title('Boxplot of Actual Price in Cleaned Dataset')

# 'selling_price'
sns.histplot(df_cleaned['selling_price'], bins=30, ax=ax[1, 0])
sns.boxplot(df_cleaned['selling_price'], ax=ax[1, 1])
ax[1, 0].set_title('Distribution of Selling Price in Cleaned Dataset')
ax[1, 1].set_title('Boxplot of Selling Price in Cleaned Dataset')

plt.tight_layout()
plt.show()

# Calculate the correlation between numerical columns
correlation = df_cleaned[['actual_price', 'selling_price']].corr()

correlation

# Brands and categories with the best average discount
average_discount_by_brand = df_cleaned.groupby('brand')['discount'].mean().sort_values(ascending=False)
average_discount_by_category = df_cleaned.groupby('category')['discount'].mean().sort_values(ascending=False)

# Top-rated brands and categories
average_rating_by_brand = df_cleaned.groupby('brand')['average_rating'].mean().sort_values(ascending=False)
average_rating_by_category = df_cleaned.groupby('category')['average_rating'].mean().sort_values(ascending=False)

# Display the top 5 brands and categories for each insight
top_5_discount_brands = average_discount_by_brand[:5]
top_5_discount_categories = average_discount_by_category[:5]
top_5_rating_brands = average_rating_by_brand[:5]
top_5_rating_categories = average_rating_by_category[:5]

top_5_discount_brands, top_5_discount_categories, top_5_rating_brands, top_5_rating_categories

# Brand Analysis

# Number of products per brand
products_per_brand = df_cleaned['brand'].value_counts()

# Average selling price per brand
avg_price_per_brand = df_cleaned.groupby('brand')['selling_price'].mean()

# Average discount per brand
avg_discount_per_brand = df_cleaned.groupby('brand')['discount'].mean()

# Average rating per brand
avg_rating_per_brand = df_cleaned.groupby('brand')['average_rating'].mean()


# Create a DataFrame for the brand analysis
df_brand_analysis = pd.DataFrame({
    'Number_of_Products': products_per_brand,
    'Average_Selling_Price': avg_price_per_brand,
    'Average_Discount': avg_discount_per_brand,
    'Average_Rating': avg_rating_per_brand
})

# Display the brand analysis DataFrame
df_brand_analysis.head()

# Number of products per category and sub-category
products_per_category = df_cleaned['category'].value_counts()
products_per_sub_category = df_cleaned['sub_category'].value_counts()

# Average selling price per category and sub-category
avg_price_per_category = df_cleaned.groupby('category')['selling_price'].mean()
avg_price_per_sub_category = df_cleaned.groupby('sub_category')['selling_price'].mean()

# Average discount per category and sub-category
avg_discount_per_category = df_cleaned.groupby('category')['discount'].mean()
avg_discount_per_sub_category = df_cleaned.groupby('sub_category')['discount'].mean()

# Average rating per category and sub-category
avg_rating_per_category = df_cleaned.groupby('category')['average_rating'].mean()
avg_rating_per_sub_category = df_cleaned.groupby('sub_category')['average_rating'].mean()

# Create DataFrames for the market analysis
df_category_analysis = pd.DataFrame({
    'Number_of_Products': products_per_category,
    'Average_Selling_Price': avg_price_per_category,
    'Average_Discount': avg_discount_per_category,
    'Average_Rating': avg_rating_per_category
})

df_sub_category_analysis = pd.DataFrame({
    'Number_of_Products': products_per_sub_category,
    'Average_Selling_Price': avg_price_per_sub_category,
    'Average_Discount': avg_discount_per_sub_category,
    'Average_Rating': avg_rating_per_sub_category
})

# Display the market analysis DataFrames
df_category_analysis, df_sub_category_analysis

# Convert 'selling_price' and 'discount' columns to numeric
df_cleaned['selling_price'] = pd.to_numeric(df_cleaned['selling_price'], errors='coerce')
df_cleaned['discount'] = pd.to_numeric(df_cleaned['discount'], errors='coerce')

# Number of products per category and sub-category
products_per_category = df_cleaned['category'].value_counts()
products_per_sub_category = df_cleaned['sub_category'].value_counts()

# Average selling price per category and sub-category
avg_price_per_category = df_cleaned.groupby('category')['selling_price'].mean()
avg_price_per_sub_category = df_cleaned.groupby('sub_category')['selling_price'].mean()

# Average discount per category and sub-category
avg_discount_per_category = df_cleaned.groupby('category')['discount'].mean()
avg_discount_per_sub_category = df_cleaned.groupby('sub_category')['discount'].mean()

# Average rating per category and sub-category
avg_rating_per_category = df_cleaned.groupby('category')['average_rating'].mean()
avg_rating_per_sub_category = df_cleaned.groupby('sub_category')['average_rating'].mean()

# Create DataFrames for the market analysis
df_category_analysis = pd.DataFrame({
    'Number_of_Products': products_per_category,
    'Average_Selling_Price': avg_price_per_category,
    'Average_Discount': avg_discount_per_category,
    'Average_Rating': avg_rating_per_category
})

df_sub_category_analysis = pd.DataFrame({
    'Number_of_Products': products_per_sub_category,
    'Average_Selling_Price': avg_price_per_sub_category,
    'Average_Discount': avg_discount_per_sub_category,
    'Average_Rating': avg_rating_per_sub_category
})

# Display the market analysis DataFrames
df_category_analysis, df_sub_category_analysis

# Initialize label encoders
brand_encoder = LabelEncoder()
category_encoder = LabelEncoder()
sub_category_encoder = LabelEncoder()

# Fit and transform the categorical features
df_cleaned['brand_encoded'] = brand_encoder.fit_transform(df_cleaned['brand'])
df_cleaned['category_encoded'] = category_encoder.fit_transform(df_cleaned['category'])
df_cleaned['sub_category_encoded'] = sub_category_encoder.fit_transform(df_cleaned['sub_category'])

# Display the first few rows of the dataframe
df_cleaned.head()

# Define the feature variables and the target variable
X = df_cleaned[['brand_encoded', 'category_encoded', 'sub_category_encoded', 'discount', 'average_rating']]
y = df_cleaned['selling_price']

# Split the dataset into a training set and a test set
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the linear regression model
lr_model = LinearRegression()

# Train the model
lr_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = lr_model.predict(X_test)

# Calculate the mean squared error of the predictions
mse = mean_squared_error(y_test, y_pred)

mse

# Calculate the Root Mean Squared Error (RMSE)
rmse = np.sqrt(mse)

rmse

# Define the feature variables and the target variable for the discount prediction task
X_discount = df_cleaned[['brand_encoded', 'category_encoded', 'sub_category_encoded', 'selling_price', 'average_rating']]
y_discount = df_cleaned['discount']

# Split the dataset into a training set and a test set
X_train_discount, X_test_discount, y_train_discount, y_test_discount = train_test_split(X_discount, y_discount, test_size=0.2, random_state=42)

# Initialize the linear regression model
lr_model_discount = LinearRegression()

# Train the model
lr_model_discount.fit(X_train_discount, y_train_discount)

# Make predictions on the test set
y_pred_discount = lr_model_discount.predict(X_test_discount)

# Calculate the mean squared error of the predictions
mse_discount = mean_squared_error(y_test_discount, y_pred_discount)

mse_discount

# Check the unique predicted values
unique_predictions = np.unique(y_pred_discount)

unique_predictions

# Define the feature variables and the target variable for the rating prediction task
X_rating = df_cleaned[['brand_encoded', 'category_encoded', 'sub_category_encoded', 'selling_price', 'discount']]
y_rating = df_cleaned['average_rating']

# Split the dataset into a training set and a test set
X_train_rating, X_test_rating, y_train_rating, y_test_rating = train_test_split(X_rating, y_rating, test_size=0.2, random_state=42)

# Initialize the linear regression model
lr_model_rating = LinearRegression()

# Train the model
lr_model_rating.fit(X_train_rating, y_train_rating)

# Make predictions on the test set
y_pred_rating = lr_model_rating.predict(X_test_rating)

# Calculate the mean squared error of the predictions
mse_rating = mean_squared_error(y_test_rating, y_pred_rating)

mse_rating

# Calculate the Root Mean Squared Error (RMSE) for the rating prediction task
rmse_rating = np.sqrt(mse_rating)

rmse_rating

"""**Decision Tree model**"""

# Initialize the decision tree model for price prediction
dt_model = DecisionTreeRegressor(random_state=42)

# Train the model
dt_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred_dt = dt_model.predict(X_test)

# Calculate the mean squared error of the predictions
mse_dt = mean_squared_error(y_test, y_pred_dt)

# Calculate the Root Mean Squared Error (RMSE)
rmse_dt = np.sqrt(mse_dt)

# Initialize the decision tree model for rating prediction
dt_model_rating = DecisionTreeRegressor(random_state=42)

# Train the model
dt_model_rating.fit(X_train_rating, y_train_rating)

# Make predictions on the test set
y_pred_dt_rating = dt_model_rating.predict(X_test_rating)

# Calculate the mean squared error of the predictions
mse_dt_rating = mean_squared_error(y_test_rating, y_pred_dt_rating)

# Calculate the Root Mean Squared Error (RMSE)
rmse_dt_rating = np.sqrt(mse_dt_rating)

rmse_dt, rmse_dt_rating

from sklearn.ensemble import RandomForestRegressor

# Initialize the random forest model for rating prediction
rf_model_rating = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
rf_model_rating.fit(X_train_rating, y_train_rating)

# Make predictions on the test set
y_pred_rf_rating = rf_model_rating.predict(X_test_rating)

# Calculate the mean squared error of the predictions
mse_rf_rating = mean_squared_error(y_test_rating, y_pred_rf_rating)

# Calculate the Root Mean Squared Error (RMSE)
rmse_rf_rating = np.sqrt(mse_rf_rating)


rmse_rf_rating

from sklearn.model_selection import GridSearchCV

# Define the parameter grid
param_grid = {
    'n_estimators': [50, 100, 200],
    'max_depth': [None, 10, 20, 30],
    'min_samples_split': [2, 5, 10]
}

# Initialize the grid search model
grid_search = GridSearchCV(RandomForestRegressor(random_state=42), param_grid, cv=3, scoring='neg_mean_squared_error')

# Fit the grid search model
grid_search.fit(X_train, y_train)

# Get the best parameters
best_params = grid_search.best_params_

best_params

# Define the feature variables and the target variable for the rating prediction task
X_rating = df_cleaned[['brand_encoded', 'category_encoded', 'sub_category_encoded', 'selling_price', 'discount']]
y_rating = df_cleaned['average_rating']

# Split the dataset into a training set and a test set
X_train_rating, X_test_rating, y_train_rating, y_test_rating = train_test_split(X_rating, y_rating, test_size=0.2, random_state=42)

from sklearn.ensemble import RandomForestRegressor

# Initialize the random forest model
rf_model = RandomForestRegressor(max_depth = None, min_samples_split= 5, n_estimators = 100)

# Train the model
rf_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred_rf = rf_model.predict(X_test)

# Create a DataFrame with actual and predicted values
df_predictions = pd.DataFrame({'Actual': y_test_rating, 'Predicted': y_pred_rf})

# Visualizing the actual and predicted ratings with a different style
plt.figure(figsize=(10, 6))

# Actual ratings as blue dots
plt.scatter(df_predictions.index, df_predictions['Actual'], color='blue', label='Actual', s=30, marker='o')

# Predicted ratings as red crosses
plt.scatter(df_predictions.index, df_predictions['Predicted'], color='red', label='Predicted', marker='x')

plt.title('Actual vs Predicted Ratings')
plt.xlabel('Index')
plt.ylabel('Rating')
plt.legend()
plt.grid(True)
plt.show()

